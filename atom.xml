<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>春雨的部落格</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://robinsonweng.github.io/"/>
  <updated>2023-10-07T08:03:50.456Z</updated>
  <id>https://robinsonweng.github.io/</id>
  
  <author>
    <name>robinson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Implment irc server in rust part 1</title>
    <link href="https://robinsonweng.github.io/2023/10/07/rust-irc-part-1/"/>
    <id>https://robinsonweng.github.io/2023/10/07/rust-irc-part-1/</id>
    <published>2023-10-07T06:45:51.000Z</published>
    <updated>2023-10-07T08:03:50.456Z</updated>
    
    <content type="html"><![CDATA[<p>原本是想要寫一個 DNS 的, 後來我朋友跟我推薦他學校的網路程式作業, 裡面就包含了 DNS, 所以想說乾脆就先從簡單的作業開始</p><h2 id="framework"><a href="#framework" class="headerlink" title="framework"></a>framework</h2><p>除了 std libary 以外啥都沒用, 一來是因為只是要用於作業, 練習如何看規格文件, 練習寫 rust 等等, 二來是減少專題的複雜程度, 三來為了避免以前在學程式語言的錯誤: 用了功能太過複雜的框架, 導致學不到東西, 浪費很多時間, 結果一場空, 既沒有學到技術, 也沒有學到基礎。這樣寫了也快兩週了, 不得不說這個決策是正確的, 畢竟一開始也不會遇到什麼 corutine, async 的問題, 而且也不需要一開始寫就要一口氣搞懂 lifetime, trait, generic 等沒接觸過的概念, 也就不會上 stackoverflow 找答案 trail and error 就為了讓程式碼能跑, 讓我可以心神安寧的寫程式。</p><h2 id="RFC-1459-amp-homework-spec"><a href="#RFC-1459-amp-homework-spec" class="headerlink" title="RFC 1459 &amp; homework spec"></a>RFC 1459 &amp; homework spec</h2><p>幾個我覺得很酷的地方:</p><ol><li>語法這種東西居然有 <a href="https://www.freecodecamp.org/news/what-are-bnf-and-ebnf/" target="_blank" rel="noopener">psuudo code</a> 可以表示, 而且還不錯用, 後續如果要拿來寫 cli, 這個東東會非常非常好用。</li><li>RFC 還是看得很不習慣, 很多東西都要細找, 重新看, 繞了不少圈</li><li>Wireshark 我的神, 之前一直懶得裝, 後來受不了去撈包下來看, 至少不會一直想東想西了</li><li>IRC 的規範不知道是我不適應 RFC, 還是很久沒更新了, 我到最後都沒搞清楚要怎麼知道哪些回覆要用哪種 prefix, 無可奈何之下只好用撈封包的方式來參考別人的作法。</li></ol><h2 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h2><ol><li>眾所皆知, rust 沒有完整的 OOP 支援, 我猜要寫可能還是可以自己實做一些功能出來, 畢竟有沒有支援 OOP 語法和能不能寫 OOP 完全是<a href="https://hackmd.io/@sysprog/c-oop" target="_blank" rel="noopener">兩回事</a>。 一路用 <a href="https://www.youtube.com/watch?v=hxGOiiR9ZKg&ab_channel=CodeAesthetic" target="_blank" rel="noopener">Composition</a> 的方式寫下來, 倒也沒有什麼不習慣的地方, 讓我蠻驚訝的, 不如說逃離 python 的魔掌我自己其實還挺爽的</li><li>rust 的生態系寫起來是真的舒服, <code>cargo watch</code> 等插件讓寫程式過程絲滑無比</li><li>rust 的 module 用起來比 go 的舒服太多了, 個人偏見</li><li>之前看過一個建議新手寫 rust 的<a href="https://youtu.be/2hXNd6x9sZs?si=POoo3vx7464yVOGH&t=555" target="_blank" rel="noopener">方法</a>就是, 全部將用最沒效率但是最好寫的方法來做, 例如一言不合就把 String Clone 或是 Struct 直接 Copy, 所有的 string literal 想都不想就直接放進 heap (String) 等, 這個建議不得不說很適合只有用過動態型態或是有 GC 的語言的工程師, 一來是寫起來程式不會有那麼多錯, 不會一堆關於 reference 和 lifetime 的問題, 降低超級多學習曲線, 而且也可以讓自己認知到之前的程式語言或是寫法的有多 <del>蠢</del> 差, 而且如果你 GC 癮犯了, 也可以去玩玩看 rust 提供的 <a href="https://doc.rust-lang.org/book/ch15-04-rc.html" target="_blank" rel="noopener">reference counter</a>。</li><li>rust 的測試寫起來很舒服, 有種本來就鼓勵你寫測試的感覺(雖然不知道到底有沒有效)</li><li>rust 的 Compilter 是我大哥, 至少現在是</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原本是想要寫一個 DNS 的, 後來我朋友跟我推薦他學校的網路程式作業, 裡面就包含了 DNS, 所以想說乾脆就先從簡單的作業開始&lt;/p&gt;
&lt;h2 id=&quot;framework&quot;&gt;&lt;a href=&quot;#framework&quot; class=&quot;headerlink&quot; title=&quot;f
      
    
    </summary>
    
    
      <category term="未分類" scheme="https://robinsonweng.github.io/categories/%E6%9C%AA%E5%88%86%E9%A1%9E/"/>
    
    
      <category term="rust" scheme="https://robinsonweng.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>為什麼你該試試看 Enum</title>
    <link href="https://robinsonweng.github.io/2023/05/31/why-you-should-try-enum/"/>
    <id>https://robinsonweng.github.io/2023/05/31/why-you-should-try-enum/</id>
    <published>2023-05-31T09:26:59.000Z</published>
    <updated>2023-06-15T09:06:46.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="為什麼你該試試看-Enum"><a href="#為什麼你該試試看-Enum" class="headerlink" title="為什麼你該試試看 Enum"></a>為什麼你該試試看 Enum</h2><p>一個幾乎每個工程師都會遇過的問題:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">weekday_list = [<span class="string">"monday"</span>, <span class="string">"tuesday"</span>, <span class="string">"wednesday"</span>, <span class="string">"thursday"</span>,  <span class="string">"friday"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_weekday</span><span class="params">(weekday: str)</span> -&gt; bool:</span></span><br><span class="line">  <span class="keyword">return</span> weekday <span class="keyword">in</span> weekday_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">is_weekday(<span class="string">"123"</span>) <span class="comment"># False</span></span><br><span class="line">is_weekday(<span class="string">"mondy"</span>) <span class="comment"># False, but no error</span></span><br><span class="line">is_weekday(<span class="string">"monday"</span>) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>這個寫法可以讓我們透過 <code>in</code> 關鍵字來檢查我們輸入的字串是否屬於 <code>weekday</code>, 但沒有辦法解決其他幾個問題:</p><ol><li>如果輸入是錯的, 那麼 <code>in</code> 會認為輸入值不屬於 <code>weekday</code>, 而無法幫助我們 raise error.</li><li>我們無法強制要求 User 輸入範圍內的值</li><li>即便 User 有輸入正確值的意願, 無法完全排除打錯字的可能</li><li>有一堆 string literal 要維護</li></ol><p>這時候 Enum 超人就出現了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekday</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    Monday = <span class="string">"monday"</span></span><br><span class="line">    Tuesday = <span class="string">"tuesday"</span></span><br><span class="line">    Wendnesday = <span class="string">"wendsday"</span></span><br><span class="line">    Thursday = <span class="string">"thursday"</span></span><br><span class="line">    Friday = <span class="string">"friday"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_weekday</span><span class="params">(weekday: Weekday)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">return</span> isinstance(weekday, Weekday)</span><br><span class="line"></span><br><span class="line">is_weekday(Weekday.Monday) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>由於 Enum 的 attribute 是 Enum 的 instance, 所以我們可以透過 <code>isinstance</code> 來檢查輸入值的格式是否為我們的 <code>Weekday</code> 成員內。 而且因為我們的選項被限制住了, 所以不能輸入這些選項以外的值(問題 2), 由於我們是透過 Enum 的成員來選擇值, 也不需要維護一堆零散的字串(問題 4, 問題 3), 而剩下 問題 1, 我們可以透過實做 dunder method 賦予 Enum 這個特性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> EnumMeta</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumContains</span><span class="params">(EnumMeta)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self: type, member: object)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self(member)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumExample</span><span class="params">(Enum, metaclass=EnumContains)</span>:</span></span><br><span class="line">    Monday = <span class="string">"monday"</span></span><br><span class="line">    Tuesday = <span class="string">"tuesday"</span></span><br><span class="line">    Wendnesday = <span class="string">"wendsday"</span></span><br><span class="line">    Thursday = <span class="string">"thursday"</span></span><br><span class="line">    Friday = <span class="string">"friday"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"friday"</span> <span class="keyword">in</span> EnumExample:</span><br><span class="line">    print(<span class="string">"friday is a valid member of enum!"</span>)</span><br></pre></td></tr></table></figure><p>很讚, 對吧。但還是得碎碎念一下, 這些資料型態的用法都是在 Python 以外的語言學到的, 總感覺哪邊不對…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;為什麼你該試試看-Enum&quot;&gt;&lt;a href=&quot;#為什麼你該試試看-Enum&quot; class=&quot;headerlink&quot; title=&quot;為什麼你該試試看 Enum&quot;&gt;&lt;/a&gt;為什麼你該試試看 Enum&lt;/h2&gt;&lt;p&gt;一個幾乎每個工程師都會遇過的問題:&lt;/p&gt;
&lt;fig
      
    
    </summary>
    
    
      <category term="Python" scheme="https://robinsonweng.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://robinsonweng.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python的垃圾回收</title>
    <link href="https://robinsonweng.github.io/2022/07/31/python-refcount/"/>
    <id>https://robinsonweng.github.io/2022/07/31/python-refcount/</id>
    <published>2022-07-31T05:15:49.000Z</published>
    <updated>2023-06-15T09:04:46.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-Garbage-Collect"><a href="#Python-Garbage-Collect" class="headerlink" title="Python Garbage Collect"></a>Python Garbage Collect</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>當初在學Python的時候，那時還年輕，以為底層甚麼的都幫我寫好了，C甚麼的好麻煩。現在回頭了解Python的記憶體配置，GC，VM等全部都是C寫成的，後悔沒有把C學好，沒辦法直接深入Python原始碼內，這篇算是一種補償心態吧XDD</p><h2 id="Why-GC"><a href="#Why-GC" class="headerlink" title="Why GC?"></a>Why GC?</h2><p>在C語言當中，我們需要掌控所有使用者模式(user mode)的一切電腦資源，從系統呼叫，分配記憶體，執行序，到陣列長度，宣告常數類型等大大小小的細節。假設今天使用者沒有對應的計算機素養，很容易覺得厭煩、沒有意義、難於使用，寫出來的程式也很容易出現問題。但Python不一樣，他的目標是語法簡單明瞭、容易學會，所以自動回收電腦資源自然也是Python需要面對的議題。</p><h2 id="Why-understand-GC"><a href="#Why-understand-GC" class="headerlink" title="Why understand GC?"></a>Why understand GC?</h2><p>大部分時間，在寫python並不需要這些背後的知識，但，了解Python的GC就像瞭解linux寫出來的C一樣。同樣的語言，給不同素養的人寫出來的效率、可讀性，就會不一樣。</p><p><a href="https://towardsdatascience.com/do-not-use-to-join-strings-in-python-f89908307273" target="_blank" rel="noopener">Why use <code>join</code> instead <code>+</code> in Python ?</a></p><h2 id="Where-is-GC"><a href="#Where-is-GC" class="headerlink" title="Where is GC?"></a>Where is GC?</h2><blockquote class="colorquote info"><p>這篇牽扯到python的記憶體分配、python的傳值方法<a href="https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/" target="_blank" rel="noopener">Pass Object by Reference</a>、everything in python is object、python直譯器以及其VM，如果對這些內容還不熟悉，可以先去補充一下基本知識</p></blockquote><h2 id="When-you-hit-enter"><a href="#When-you-hit-enter" class="headerlink" title="When you hit enter"></a>When you hit enter</h2><p>當我們執行一段程式碼的時候，直譯器會把程式碼拆成兩部分，分別是block&amp;變數名稱 以及 object</p><!-- pic for block & object vs stack & heap--><p>block和變數名稱會被放進直譯器裡面的stack，而object會被放進heap裡面。在寫C的時候，我們透過記憶體位址操作、呼叫資料結構，而Python為了避免使用者直接接觸到記憶體議題，將記憶體位址改為<code>id</code></p><blockquote class="colorquote warning"><p>雖然id(Identity)，語意為身分、身分識別，但在Python的<a href="https://docs.python.org/3/library/functions.html#id" target="_blank" rel="noopener">官方文檔</a>中提到:</p><blockquote><p>CPython implementation detail: This is the address of the object in memory.</p></blockquote><p>所以<code>id</code>雖然不是平常表現記憶體位址的十六進位數字，但也不是隨隨便便的一串數字</p></blockquote><h2 id="Reference-Count"><a href="#Reference-Count" class="headerlink" title="Reference Count"></a>Reference Count</h2><p>要能夠回收不需要的資源，首先得先知道哪些資源正被使用，那些沒有被使用。算出當下物件被多少人使用，並將沒有人使用的物件(計數器為0)的物件回收，就是引用計數的目的。</p><!-- pic for reference count --><p>每當物件的引用增加(通常是宣告、繼承)，這個物件的計數器就會+1，相反，當這個物件的引用減少，例如呼叫<code>del</code>，那麼這個物件的計數器就會-1</p><h3 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h3><ul><li>實作簡單</li><li>回收過程不需要有很長的停頓</li></ul><h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><ul><li>需要額外的記憶體空間去存放計數器</li><li>在linux底下運作時，<a href="https://instagram-engineering.com/dismissing-python-garbage-collection-at-instagram-4dca40b29172" target="_blank" rel="noopener">計數器更新會頻繁觸發COW</a></li></ul><h3 id="Pass-by-object-reference-以list為例"><a href="#Pass-by-object-reference-以list為例" class="headerlink" title="Pass by object reference(以list為例)"></a>Pass by object reference(以list為例)</h3><p>在C語言中，假設要複製一個array的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">9</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *b;</span><br><span class="line">b = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the direction of b is at: %p\n"</span>, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the direction of a is at: %p\n"</span>, &amp;a);</span><br></pre></td></tr></table></figure><p>印出來的會是兩個完全不一樣的位址(pass by value)，又或者透過傳地址標的方式來達到 pass by reference<br>但在python中，假設我們對<code>list</code>做出相同的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">b = a</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'the direction of b is at: <span class="subst">&#123;id(b)&#125;</span>\n'</span>)</span><br><span class="line">print(<span class="string">f'the direction of a is at: <span class="subst">&#123;id(a)&#125;</span>\n'</span>)</span><br></pre></td></tr></table></figure><p>我們會的到兩個完全相同的<code>id</code>(pass object by reference)</p><p>也就是為甚麼我們複製一個<code>list</code>需要import <a href="https://docs.python.org/3/library/copy.html" target="_blank" rel="noopener"><code>copy</code></a>這個標準函式庫，才會真正複製一個新的list出來，因為在Python當中，<code>b=a</code>只不過是將<code>a</code>的<code>id</code>複製給<code>b</code>，也就是共享同一個<code>list</code>的引用而已</p><h3 id="傳遞引用的所有權"><a href="#傳遞引用的所有權" class="headerlink" title="傳遞引用的所有權"></a>傳遞引用的所有權</h3><p>從上個例子可以看到，當我們宣告某個變數時，他並不擁有這個物件，而是擁有這個物件的<code>id</code>，也就是物件的引用，藉此將記憶體分配、施放記憶體等議題從使用者的層面隔離掉。為此，當無人擁有這個物件的引用時，python得負起責任釋放掉這個物件</p><h2 id="Tracing"><a href="#Tracing" class="headerlink" title="Tracing"></a>Tracing</h2><p>雖然引用計數可以幫助我們找出那些閒置的物件並加以回收，但這時候會遇到一個問題。</p><!-- pic for circulus ref --><!-- spider man meme --><p>假設我們今天有兩個物件互相引用呢?你引用我，我引用你，無論如何計數都是1。這就是循環引用(reference cycles)，這類現象常常會出現在遞迴、雙向連接串列。而這就是tracing的核心目的，偵測出循環引用並加以排除。python使用的是標記-掃描演算法(Mark &amp; Sweep)</p><p><img src="https://i.imgur.com/fNKBCap.jpg" alt=""></p><h3 id="Mark-amp-Sweep"><a href="#Mark-amp-Sweep" class="headerlink" title="Mark &amp; Sweep"></a>Mark &amp; Sweep</h3><p>下圖是物件互相引用的例圖</p><p><img src="https://i.imgur.com/rLd6nzb.png" alt=""></p><p>基於python的記憶體配置，所有的物件在生成前就被串成雙向環形串列，如下圖，又稱為arena</p><p><img src="https://i.imgur.com/6AsoX7k.png" alt=""></p><h4 id="標記-清除演算法"><a href="#標記-清除演算法" class="headerlink" title="標記-清除演算法"></a>標記-清除演算法</h4><p>首先，先將計數器複製到左方格子中</p><p><img src="https://i.imgur.com/KQApw3e.png" alt=""></p><p>接下來，只要是被python物件引用的，我們就對剛剛複製的計數器-1，所以像obj1這種被root引用的，我們就不更動</p><p><img src="https://i.imgur.com/ASIu9jr.png" alt=""></p><p>接下來，我們把這些串列分成兩組:</p><ol><li>reachable<ul><li>經過-1後計數器不為0或者有被正在活動的物件引用</li></ul></li><li>unreachable<ul><li>計數器為0而且沒有被正在活動的物件引用</li></ul></li></ol><p><img src="https://i.imgur.com/zf2Ukeb.png" alt=""></p><p>最後，我們將unreachable整個串列釋放，並將reachable串列還給head，完成這次的GC</p><p><img src="https://i.imgur.com/tCCOeI8.png" alt=""></p><h3 id="Generation-Collection"><a href="#Generation-Collection" class="headerlink" title="Generation Collection"></a>Generation Collection</h3><p>這時候可能就有人要問了，假設今天我有很多瑣碎的小物件不斷的進行分配和釋放，是不是就會需要不斷的去進行這種走訪串列，頻繁的去修正引用記數呢? 答案是會的，為此，python還引進了分代回收，分類出高頻率以及低頻率的物件進行回收，而不至於要走訪所有的串列</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python-Garbage-Collect&quot;&gt;&lt;a href=&quot;#Python-Garbage-Collect&quot; class=&quot;headerlink&quot; title=&quot;Python Garbage Collect&quot;&gt;&lt;/a&gt;Python Garbage Colle
      
    
    </summary>
    
    
      <category term="Python" scheme="https://robinsonweng.github.io/categories/Python/"/>
    
    
      <category term="c" scheme="https://robinsonweng.github.io/tags/c/"/>
    
      <category term="python" scheme="https://robinsonweng.github.io/tags/python/"/>
    
      <category term="garbage collect" scheme="https://robinsonweng.github.io/tags/garbage-collect/"/>
    
  </entry>
  
  <entry>
    <title>用asyncio以前，你需要注意的事情</title>
    <link href="https://robinsonweng.github.io/2022/01/08/before-using-asyncio/"/>
    <id>https://robinsonweng.github.io/2022/01/08/before-using-asyncio/</id>
    <published>2022-01-08T05:08:47.000Z</published>
    <updated>2023-06-15T09:04:55.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-asyncio只不過是python-coroutine的一種實現方法"><a href="#1-asyncio只不過是python-coroutine的一種實現方法" class="headerlink" title="1. asyncio只不過是python coroutine的一種實現方法"></a>1. asyncio只不過是python coroutine的一種實現方法</h2><p>掌握寫coroutine的好處與壞處，實作的時機，雷點以及隱憂，如何排錯，遠遠比用甚麼炫泡函式庫無腦加上async/await還要重要上好幾倍(對說的就是我)，除了asyncio，gevent，trio都可以去多看看人家的文檔，是怎麼實作出來的，跟其他模組差在哪邊</p><h2 id="2-任何事情都有代價"><a href="#2-任何事情都有代價" class="headerlink" title="2. 任何事情都有代價"></a>2. 任何事情都有代價</h2><p>雖然async常常標榜不需要管理討厭的鎖、效能提升，但有很多東西是他們沒有提到，卻是寫出好coroutine的關鍵</p><p>不需要管理討厭的鎖<br>是，async的確不需要管討厭的鎖了，但作為代價，async的context switch 並不會像thread那樣有固定規律，並且由於async的實現方式只是由main thread管控context switch，沒有額外的限制就會出現像是 back-pressure 的問題。沒有固定規律要debug跟解決bug都是個難題。不要用了asyncio幻想自己「我只要用async就可以不用去理解thread, process, lock…」，只會在後面付出代價而已。</p><p>效能提升<br>前面的惡夢還沒結束，社群又多了一個奇怪的傳言「async會提升效能」這一論點，而這對我來說就是將程式語言本身作為解決問題的工具的癥結點。這點在 評論以前的文章 當中曾經有提到過:</p><blockquote class="colorquote info"><p>程式語言不是解決問題的工具，他是用來做出解決問題的模型的工具，解決問題與否最終還是得取決於工程師本身</p></blockquote><p>如果用榔頭把釘子釘在錯的位置，椅子自然是不堪一擊。同理，專案並不會因為加入了coroutine或是asyncio就會變快，而是在經過評估，在正確使用的前提之下才會得到較多的好處，較少的壞處，就我所知，主要有以下幾個使用情境:</p><ul><li>任務多為I/O類型，並且大部分時間在wait</li><li>不該有任務吃需要大量cpu計算</li><li>有一定程度的流量或是執行次數</li></ul><p>並且影響效能的也不只與async/sync有關，以網頁為例，在django/flask上寫了async code，並不代表他在gunicorn/uwsgi上執行的效率會一樣，也不代表就可以用效率差的方式去query database。而且很多框架在benchmark的時候並沒有詳細交代參數與環境變因，數字看起來很棒其實也沒啥用</p><p><img src="https://i.imgur.com/vU11HSS.jpeg" alt=""></p><p><a href="https://lumen.golaravel.com/" target="_blank" rel="noopener">source</a></p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>重新審視我對coroutine的看法讓我有新的發現，但整理完這些資料讓我想到新的問題: 「asyncio會影響到TCP/IP的握手效率嗎?」</p><p>2022-01-09 update:<br>答案是不會，以django為例，在web app收到request的時候，他已經是第四次握手(傳輸資料階段)了</p><p>2022-01-24 update:<br>有熱心路人提醒，coro是否會提升Http握手效能還會取決於Http的版本，例如 Http/1.1支援 keep alive， 而 Http/1.0不支援，所以在Http/1.0上使用coro的資源會比Http/1.1還多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-asyncio只不過是python-coroutine的一種實現方法&quot;&gt;&lt;a href=&quot;#1-asyncio只不過是python-coroutine的一種實現方法&quot; class=&quot;headerlink&quot; title=&quot;1. asyncio只不過是python
      
    
    </summary>
    
    
      <category term="Python" scheme="https://robinsonweng.github.io/categories/Python/"/>
    
    
      <category term="corutine" scheme="https://robinsonweng.github.io/tags/corutine/"/>
    
      <category term="asyncio" scheme="https://robinsonweng.github.io/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>RESTful Service Best practice 2013</title>
    <link href="https://robinsonweng.github.io/2022/01/08/restful-service-best-practice-13/"/>
    <id>https://robinsonweng.github.io/2022/01/08/restful-service-best-practice-13/</id>
    <published>2022-01-08T05:08:47.000Z</published>
    <updated>2023-06-15T09:04:31.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RESTful-Service-Best-Practices-2013"><a href="#RESTful-Service-Best-Practices-2013" class="headerlink" title="RESTful Service Best Practices (2013)"></a>RESTful Service Best Practices (2013)</h1><p><a href="https://www.redhat.com/en/topics/api/what-is-a-rest-api" target="_blank" rel="noopener">https://www.redhat.com/en/topics/api/what-is-a-rest-api</a><br><a href="https://www.redhat.com/en/topics/integration/whats-the-difference-between-soap-rest" target="_blank" rel="noopener">https://www.redhat.com/en/topics/integration/whats-the-difference-between-soap-rest</a><br><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank" rel="noopener">https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a><br><a href="https://zh.wikipedia.org/zh-tw/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-tw/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2</a></p><p><a href="https://restfulapi.net/" target="_blank" rel="noopener">https://restfulapi.net/</a></p><p><a href="https://ihower.tw/blog/archives/1542" target="_blank" rel="noopener">https://ihower.tw/blog/archives/1542</a></p><p><a href="https://www.restapitutorial.com/" target="_blank" rel="noopener">https://www.restapitutorial.com/</a></p><p><a href="https://raw.githubusercontent.com/tfredrich/RestApiTutorial.com/master/media/RESTful%20Best%20Practices-v1_2.pdf" target="_blank" rel="noopener">原文連接</a></p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Restful 的六大規範為</p><ul><li>Uniform Interface</li><li>Stateless</li><li>Cacheable</li><li>Client-Server</li><li>Layered System</li><li>Code on Demand</li></ul><p>目前著重在前三點上面</p><h2 id="Http-Methods"><a href="#Http-Methods" class="headerlink" title="Http Methods"></a>Http Methods</h2><p>主要與 restful 相關的 http method有</p><ul><li>GET</li><li>POST</li><li>PUT</li><li>DELETE</li></ul><p>:::info<br>沒有直接相關的 method:</p><ul><li>OPTION</li><li>HEAD<br>:::</li></ul><h2 id="Uniform-Interface"><a href="#Uniform-Interface" class="headerlink" title="Uniform Interface"></a>Uniform Interface</h2><p>統一界面規範了使用者與伺服器之間的溝通界面. 它簡化以及減少了系統架構的耦合問題, 令每個部份都能夠各自獨立運行. 以下四個規範的統一界面為</p><ul><li><p>identifying resources</p></li><li><p>manipulation through representations</p></li><li><p>self describing messages</p></li><li><p>HATEOAS</p><ul><li><p>一種能與使用者互動的規範</p><p>:::info<br>取自維基百科:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 請求</span></span><br><span class="line">GET /accounts/12345 HTTP/1.1</span><br><span class="line">Host: bank.example.com</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回應</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"account"</span>: &#123;</span><br><span class="line">        <span class="attr">"account_number"</span>: <span class="number">12345</span>,</span><br><span class="line">        <span class="attr">"balance"</span>: &#123;</span><br><span class="line">            <span class="attr">"currency"</span>: <span class="string">"usd"</span>,</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">100.00</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"links"</span>: &#123;</span><br><span class="line">            <span class="attr">"deposits"</span>: <span class="string">"/accounts/12345/deposits"</span>,</span><br><span class="line">            <span class="attr">"withdrawals"</span>: <span class="string">"/accounts/12345/withdrawals"</span>,</span><br><span class="line">            <span class="attr">"transfers"</span>: <span class="string">"/accounts/12345/transfers"</span>,</span><br><span class="line">            <span class="attr">"close-requests"</span>: <span class="string">"/accounts/12345/close-requests"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:::</p></li></ul></li></ul><h3 id="Resource-Based"><a href="#Resource-Based" class="headerlink" title="Resource Based"></a>Resource Based</h3><p>每個資源透過uri去做辨認, 但資源本身與資源表示在概念上是分開的, 例如我們不會回傳整個資料庫, 卻會回傳類似概念的 json</p><h3 id="Manipulation-of-Resources-Through-Representations"><a href="#Manipulation-of-Resources-Through-Representations" class="headerlink" title="Manipulation of Resources Through Representations"></a>Manipulation of Resources Through Representations</h3><p>當用戶端取得了資源表示方式, 包含任何附加的metadata, 它(表示方式)都應該要有足夠的資訊去修改或刪除伺服器上的資源, 前提是使用者有這個權限</p><h3 id="Self-descriptive-Messages"><a href="#Self-descriptive-Messages" class="headerlink" title="Self-descriptive Messages"></a>Self-descriptive Messages</h3><p>每個情求都需要包含足夠的訊息來解釋如何消化這則訊息, 舉例: 哪個媒體該用哪種解析器(mime.type) 回應也會顯性的標示他們是否可快取</p><h3 id="HATEOAS"><a href="#HATEOAS" class="headerlink" title="HATEOAS"></a>HATEOAS</h3><p>很像互動式的文檔, 假設使用者請求了某段網址的集合, 回應其集合網址</p><h2 id="Stateless"><a href="#Stateless" class="headerlink" title="Stateless"></a>Stateless</h2><p>無狀態, 意指所有請求都應該是獨立的操作, 一個請求內就應該包含了所有的資訊, 身份認證, 參數, header, body, 當下請求狀態, 再交給伺服器去辨認<br>在 REST 規範下, 使用者應該要負責提供所有的資訊去滿足這個需求, 伺服器不需要去維護使用者的 session, 如果使用者需要多個回應那就需要送出多個請求(伺服器不會主動聯繫使用者), 由於我們不需要去維護使用者的狀態, 提供了伺服器很大的擴展性. 並且 load balancers 也免去了考慮 session affinity 的問題<br>有時候點開上一頁, 網頁提醒你說這個頁面不會儲存你的狀態, 其中一個原因就是它會違反stateless的規範.<br>但也是會一些例外會打破這個規則, 如 three-legged OAuth, api call rate limiting, etc. 但請進可能達到這個目的</p><h2 id="Cacheable"><a href="#Cacheable" class="headerlink" title="Cacheable"></a>Cacheable</h2><p>顯性或隱性的定義回應是否能夠快取</p><h2 id="REST-Quick-Tips-速記重點"><a href="#REST-Quick-Tips-速記重點" class="headerlink" title="REST Quick Tips(速記重點)"></a>REST Quick Tips(速記重點)</h2><h3 id="透過-HTTP-動詞來進行動作"><a href="#透過-HTTP-動詞來進行動作" class="headerlink" title="透過 HTTP 動詞來進行動作"></a>透過 HTTP 動詞來進行動作</h3><p>任何 API 接收者都有能力傳送, GET, POST, PUT, and DELETE 這些動詞, 他們很大程度上釐清了 API 當下的動作為何. 並且 GET request <strong>不能</strong> 更改任何資源. 測量或是追蹤可以更新資料, 但不能是 uri 能夠指定的資料</p><h3 id="敏感的資源名稱"><a href="#敏感的資源名稱" class="headerlink" title="敏感的資源名稱"></a>敏感的資源名稱</h3><p>使用敏感的資源名稱或路徑<br>e.g.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; type 以及 id 都是非必要的, 這樣違反 restful api 的規範</span><br><span class="line">&#x2F;api?type&#x3D;posts&amp;id&#x3D;23</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 這樣 type 以及 id 在網址中就是必要的, 符合 restful api 的規範</span><br><span class="line">&#x2F;api&#x2F;posts&#x2F;23</span><br></pre></td></tr></table></figure><h3 id="XML-and-JSON"><a href="#XML-and-JSON" class="headerlink" title="XML and JSON"></a>XML and JSON</h3><h3 id="Create-Fine-Grained-Resources"><a href="#Create-Fine-Grained-Resources" class="headerlink" title="Create Fine Grained Resources"></a>Create Fine Grained Resources</h3><p>先從細小的, 容易定義的 CRUD API 開始</p><h3 id="Consider-Connectedness"><a href="#Consider-Connectedness" class="headerlink" title="Consider Connectedness"></a>Consider Connectedness</h3><p>連貫性, 如果分頁類的功能有 first, last, next, and prev 連接,會很有幫助</p><h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><h3 id="Idempotence"><a href="#Idempotence" class="headerlink" title="Idempotence"></a>Idempotence</h3><p>連續執行同一串網址, 結果(資料)是否有改變</p><table><thead><tr><th>http method</th><th>is  Idempotence</th><th>備註</th></tr></thead><tbody><tr><td>GET</td><td>True</td><td>Text</td></tr><tr><td>OPTIONS</td><td>True</td><td>Text</td></tr><tr><td>HEAD</td><td>True</td><td>Text</td></tr><tr><td>TRACE</td><td>True</td><td>Text</td></tr><tr><td>PUT</td><td>True</td><td>有例外</td></tr><tr><td>DELETE</td><td>True</td><td>有例外</td></tr><tr><td>POST</td><td>False</td><td>Text</td></tr></tbody></table><!--post put delete state--><h3 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h3><p>:::info<br>這裡的 safe 指的是 thread safe 中的 safe<br>:::</p><p>以下 http method 不能改變伺服器的狀態</p><ul><li>HEAD</li><li>GET</li><li>OPTIONS</li><li>TRACE</li></ul><h2 id="Http-動詞"><a href="#Http-動詞" class="headerlink" title="Http 動詞"></a>Http 動詞</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>在 GET 用於讀取伺服器資料庫且不更改的狀況下, 他是 safe 的. 不要透過 GET method 去更改任何伺服器資源</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>PUT 大多用於更新資料, PUTing to a known resource URI.<br>但 PUT 也可以用於創建資源, 假設使用者有決定好的資源 id 以及路徑, 就會使用 PUT 而不是 POST</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>Post 最常用的情境就是創建一個新的資源. 特別是用在從屬資源上, 也就是說, 創建一個新的資源, Post 到這個父類別然後伺服器負責關聯一個新資源在這個父類別之下, 並隨之分配一個 ID(新資源uri), etc.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 創建一個資源 uri, customers&#x2F;12345</span><br><span class="line">POST http:&#x2F;&#x2F;www.example.com&#x2F;customers</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 創建一個資源 uri, customers&#x2F;12345&#x2F;orders&#x2F;45678</span><br><span class="line">POST http:&#x2F;&#x2F;www.example.com&#x2F;customers&#x2F;12345&#x2F;orders</span><br></pre></td></tr></table></figure><p>POST 既不安全也不 idempotent. 它就是設計用來做 non-idempotent 的資源請求.<br>使用者請求兩個相同資訊的 POST request的話, 大多數情況是回傳相同的資源</p><h3 id="PUT-vs-POST-for-Creation"><a href="#PUT-vs-POST-for-Creation" class="headerlink" title="PUT vs POST for Creation"></a>PUT vs POST for Creation</h3><p>總而言之, 請優先選擇 POST 作為資源的創建. 除此之外, 如果使用者知道更新資源的完整 URI, 用 PUT; 如果使用者選擇創建新的資源, 或者在創建資源前不知道該資源的 URI, 使用 POST</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>DELETE是用於刪除該資源的 method</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;customers&#x2F;12345</span><br><span class="line">DELETE &#x2F;customers&#x2F;12345&#x2F;orders</span><br><span class="line">DELETE</span><br></pre></td></tr></table></figure><p>當 DELETE 成功時, 它回會回傳一個 200(ok) 和一個 response body. 他有可能是當下被刪除資源的資訊或是表示法(大多會消耗很多頻寬資源), 或一個包裝好的回覆(見下方表格). 或者回傳 204 No Content 並完全沒有 response body 會是比較推薦的回覆</p><p>在 HTTP 的規格上來說, DELETE 是 idempotent. 如果你 DELETE 一個資源, 它被刪除, 你重複呼叫 DELETE 只會得到相同的結果, 它被刪除. 如果將 DELETE 用於 decrements counter 的話, 那這個 DELETE 就不再是 idempotent. 就像之前提到的那樣, 用量統計和測量可能已經更新, 但如果服務是 non-idempotent, 我們可能還需要考量資源/資料是否有更改. 總而言之, 推薦在non-idempotent 資源的請求 使用 POST</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><table><thead><tr><th>HTTP Verb</th><th>/customers</th><th>/customers/{id}</th></tr></thead><tbody><tr><td>GET</td><td>200(ok) list of customers. Use pagination if needed</td><td>200(ok) single customer</td></tr><tr><td>PUT</td><td>404 Not Found, 除非你想要更新整段資源</td><td>200 or 204. 404 if id not found.</td></tr><tr><td>POST</td><td>201, ‘Location’ header with link to /customers/{id} containing new ID</td><td>404</td></tr><tr><td>DELETE</td><td>404, 除非你想要刪掉整段資源</td><td>202. 404 if id not found</td></tr></tbody></table><h2 id="Resource-Naming"><a href="#Resource-Naming" class="headerlink" title="Resource Naming"></a>Resource Naming</h2><p>為了更有效的利用 http method, 創建一個資源命名是一個易懂, 好操作的 API 是最重要也最具討論性的概念. 好的命名會讓 API 有很直觀的操作方式.<br>在決定要為資源命名時, 不要使用動詞或行為而使用名詞去命名他們. 也就是說, 一個 RESTful URI 應該要代表一個資源為一個物體而不是一個行為. 名詞有特質而動詞沒有, 如:</p><ul><li>系統內的使用者</li><li>學生註冊的課程</li><li>使用者的貼文動態</li><li>使用者的追蹤清單</li><li>一篇關於騎馬的文章</li></ul><p>在一套服務裡面, 每個資源至少都要有一個 URI 去做辨認. URI 最好合理並能夠表達資源. URI 最好有:</p><ul><li>可預測性</li><li>階層式結構</li></ul><p>來實現可讀性以及可用性, 也就是說如果資料之間是有連續, 階層式的結構關係, 能夠幫助我們規範好的 RESTful API</p><h3 id="Use-Case"><a href="#Use-Case" class="headerlink" title="Use Case"></a>Use Case</h3><p>插入一個新的 customer:</p><figure class="highlight plain"><figcaption><span>/customers```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">透過 customer id 去讀取一個 customer:</span><br><span class="line">&#96;&#96;&#96;GET &#x2F;customers&#x2F;33245</span><br></pre></td></tr></table></figure><p>相同的 URI 也可以用在 PUT 和 DELETE</p><p>創建一個新的 products:</p><figure class="highlight plain"><figcaption><span>/products```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">讀取&#x2F;更新&#x2F;刪除 products id 66432</span><br><span class="line">&#96;&#96;&#96;GET|PUT|DELETE products&#x2F;66432</span><br></pre></td></tr></table></figure><p>如果 customer 要創建一個新的訂單的話呢?<br>一個可能的選項為:</p><figure class="highlight plain"><figcaption><span>/orders```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">這樣或許能創建訂單, 但 訂單與 customer 的關係被排除在了這段 URI 當中</span><br><span class="line"></span><br><span class="line">一個比較清楚的 URI 為:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;POST &#x2F;customers&#x2F;33245&#x2F;orders</span><br></pre></td></tr></table></figure><p>這樣不論是使用者或是伺服器都能很清楚的知道我們要為 customers #33245 創建一個訂單</p><p>那麼這段 URI 應該要得到什麼回應？</p><figure class="highlight plain"><figcaption><span>/customers/33245/orders```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">有可能是 customers 創建的所有訂單</span><br><span class="line">:::info</span><br><span class="line">最好不要在一組集合(如上述)實現 PUT 或是 DELETE 的功能</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">如果檢視所有訂單並不需要 customer 的過濾, 也可以直接發出這樣的請求:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;GET &#x2F;orders&#x2F;8769</span><br></pre></td></tr></table></figure><h3 id="Resource-Naming-Anti-Patterns"><a href="#Resource-Naming-Anti-Patterns" class="headerlink" title="Resource Naming Anti Patterns"></a>Resource Naming Anti Patterns</h3><h4 id="Query-in-RESTful-API"><a href="#Query-in-RESTful-API" class="headerlink" title="Query in RESTful API"></a>Query in RESTful API</h4><p>一個剛接觸 RESTful API 的使用者最常搞混的概念:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;servies?op&#x3D;update_customer&amp;id&#x3D;12345&amp;format&#x3D;json</span><br></pre></td></tr></table></figure><p>vs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;servies&#x2F;customer&#x2F;12345?format&#x3D;json</span><br></pre></td></tr></table></figure><p>差在哪邊? 其實很簡單, 因為 http query 在 URI 裡面不是必要的, 這樣並沒有很清楚的表達我們請求這個資源到底 <strong>必須</strong> 知道傳送哪些資訊.<br>簡單來說, 前者是 optional, 後者是 requirement.</p><h4 id="Verb-in-uri"><a href="#Verb-in-uri" class="headerlink" title="Verb in uri"></a>Verb in uri</h4><p>另外一個常見的錯誤是下面這個 uri</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;update_customer&#x2F;12345</span><br></pre></td></tr></table></figure><p>以及他的邪惡雙胞胎</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;customers&#x2F;12345&#x2F;update</span><br></pre></td></tr></table></figure><p>你會在很多服務看見很多這類設計, 但最好的設計是透過 http method 表示 API 的動作, 在 URI 表示資源的名詞以及特徵, 這個反直覺的設計不但看起來痛苦, 甚至是危險的, 使用者分不清楚究竟決定伺服器行為到底是在 http method 還是在 uri 內, 例如以下 uri:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;customers&#x2F;12345&#x2F;update</span><br></pre></td></tr></table></figure><p>究竟更新 customers 12345 的因素是因為透過 PUT 這個 http method 呢? 還是 uri 當中的 update route? 這類設計是非常容易讓使用者搞混</p><h3 id="Pluralization"><a href="#Pluralization" class="headerlink" title="Pluralization"></a>Pluralization</h3><p>我們來談談關於名詞的複數以及個數, 請見以下 uri:</p><p>GET /<strong>customer</strong>/33245</p><p>vs</p><p>GET /<strong>customers</strong>/33245</p><p>兩種作法都有其合理的論點, 但比較能被人接受的作法是用複數來形容資源, 理由是 customers 是 customer id 的集合, 而 33445 則是表示 customers 的其中一個資源</p><h3 id="Wrapped-Responses"><a href="#Wrapped-Responses" class="headerlink" title="Wrapped Responses"></a>Wrapped Responses</h3><p>服務有機會在同一個 request 回傳 header 和 body. 在許多的 js 框架當中, http status code 並沒有回傳到 end-dev 手上, 大多是為了防止 client 基於 status code 去中斷.<br>當下最標準的 json response 需要滿足以下特質</p><ul><li><p>code</p><ul><li>http status code as an interger </li></ul></li><li><p>status</p><ul><li><p>有三個型態, success, fail, or error. “fail” 用於 HTTP status 回傳值在 500-599之間, “error” 用於 400-499之間, 以及 “success” 是給剩餘的範圍 (1XX, 2XX, 3XX)<br>  :::info<br>  註: 在 http status code 的規範中(rfc 7231), 以上範圍的數值個別意義為:</p><ul><li><p>1XX:</p><ul><li>Informational Responses</li></ul></li><li><p>2XX:</p><ul><li>Success</li></ul></li><li><p>3XX:</p><ul><li>Redirect</li></ul></li><li><p>4XX:</p><ul><li>Client side error</li></ul></li><li><p>5XX:</p><ul><li>Server side error</li></ul><p>參考資料:<br><a href="https://www.rfc-editor.org/rfc/rfc7231#section-6.5.1" target="_blank" rel="noopener">rfc7231</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Status" target="_blank" rel="noopener">MDN 好讀版</a><br>:::</p></li></ul></li></ul></li><li><p>message</p></li><li><p>data</p></li></ul><p>一個回傳成功的 json 會如同以下範例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    &quot;code&quot;:200,</span><br><span class="line">    &quot;status&quot;:&quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;lacksTOS&quot;:false,</span><br><span class="line">        &quot;invalidCredentials&quot;:false,</span><br><span class="line">        &quot;authToken&quot;:&quot;4ee683baa2a3332c3c86026d&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一個回傳失敗的 json 會如同以下範例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;:401,</span><br><span class="line">    &quot;status&quot;:&quot;error&quot;,</span><br><span class="line">    &quot;message&quot;:&quot;token is invalid&quot;,</span><br><span class="line">    &quot;data&quot;:&quot;UnauthorizedException&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Querying-Filtering-and-Pagination"><a href="#Querying-Filtering-and-Pagination" class="headerlink" title="Querying, Filtering and Pagination"></a>Querying, Filtering and Pagination</h2><p>以頻寬的角度來說, 將大量的資料切分為數個部份是很重要的, 這對於 UI 來說也很重要, 因為 UI 最多也只能顯示一小部份的資料. 在資料不停成長的情境之下, 預設回傳的資料量是ㄧ件相當關鍵的事情. 以向 Twitter API 請求使用者的動態為例, 如果沒有指定, 系統預設回傳 20 篇貼文, 即便在有指定的前提之下最大依然只能回傳 200 篇.<br>除了限制回傳的數量以外, 我們也需要考慮要如何 分頁/滾動 整組資料集, 回傳部份資料集並能夠<br>在大量的資料集當中 “上一頁”, “下一頁”.<br>目前主要有兩組方法來限制分頁的查詢.</p><ol><li>索引的格式要嘛是 page-oriented 或是 item-oriented, 指定一個 id 或是一頁物物品</li><li>指定一個範圍</li></ol><p>也就是說 “以每 20 個物體為一頁, 給我第五頁” 或是 “給我第 100 個物品到第 120 個物品”<br>推薦伺服器上兩者都能實現, 有些 js 工具甚至使用 http header 中的 <code>Range</code> 作為分頁的索引</p><p>:::info<br>參考:<br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range" target="_blank" rel="noopener">MDN Headers: Range</a><br>:::</p><h3 id="Limiting-Results"><a href="#Limiting-Results" class="headerlink" title="Limiting Results"></a>Limiting Results</h3><p>就像上面提到的那樣, 我們希望伺服器最好能夠實現 query 的分頁法(offset 和 limit), 以及 http header 的 <code>Range</code> 方法. 要注意的是 query 以及 header 分頁都在同一個請求的前提之下, query 分頁法要能夠覆蓋 header 分頁法.</p><p>要實做兩個有時無法取得相同資料的功能在同一個功能裡面會不會令人很混淆? 我們其實是希望 query 分頁是給一般使用者使用, 而 <code>Range</code> 分頁是讓基於 http 規範的函式庫來操作</p><h4 id="Limiting-via-the-Range-Header"><a href="#Limiting-via-the-Range-Header" class="headerlink" title="Limiting via the Range Header"></a>Limiting via the Range Header</h4><p>使用者端透過 header <code>Range</code> 請求分頁的格式為:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: items&#x3D;0-24</span><br></pre></td></tr></table></figure><h2 id="Supporting-CORS"><a href="#Supporting-CORS" class="headerlink" title="Supporting CORS"></a>Supporting CORS</h2><h3 id="Handling-Cross-Domain-Issues"><a href="#Handling-Cross-Domain-Issues" class="headerlink" title="Handling Cross-Domain Issues"></a>Handling Cross-Domain Issues</h3><h2 id="Service-Versioning"><a href="#Service-Versioning" class="headerlink" title="Service Versioning"></a>Service Versioning</h2><h3 id="什麼時候要開始一個新的-API-版本"><a href="#什麼時候要開始一個新的-API-版本" class="headerlink" title="什麼時候要開始一個新的 API 版本?"></a>什麼時候要開始一個新的 API 版本?</h3><ul><li>更改一個特徵的名稱, 如: 從 “name” -&gt; “firstName”</li><li>移除一個特徵</li><li>改變特徵的資料型態, 如: 從 int -&gt; str, str -&gt; bool</li><li>驗證的方式改變</li><li>In Atom style link</li><li>一個必要的新資源被新增在了原本的工作流程內</li><li>資源概念改變; 資源的概念或意義或資源的狀態與以前相比有差異, 如<ul><li>舊的 content-type: text/html 原本會回傳一組連接, 新的變成會回傳一個 web browser form 作為使用者輸入</li></ul></li><li>一個 API populating “endTime” <code>/users/{id}/exams/{id}</code> 原本是學生當下註冊考試的時間, 現在的意思為排定的考試結束時間</li><li>新增一個新的區域</li></ul><h3 id="一些不會弄壞-API-的更新"><a href="#一些不會弄壞-API-的更新" class="headerlink" title="一些不會弄壞 API 的更新"></a>一些不會弄壞 API 的更新</h3><ul><li>新的特徵被加入到 json</li><li>新的連接被加入到其他資源中</li><li>支援新的 content-type 類型</li><li>新的 content-language 格式<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h3>如果版本過期, 在 header 加入 <code>Deprecated: True</code></li></ul><h2 id="Date-Time-Handling"><a href="#Date-Time-Handling" class="headerlink" title="Date/Time Handling"></a>Date/Time Handling</h2><p>時間戳記需要被服務以 UTC 或是 GMT 格式的方式儲存, 消化, 快取 etc</p><h3 id="在-Body-Content-的時間序列"><a href="#在-Body-Content-的時間序列" class="headerlink" title="在 Body Content 的時間序列"></a>在 Body Content 的時間序列</h3><p>有一個最簡單&amp;通用的方式來解決這個問題————永遠都用一樣的格式, 包含時間的片段也一樣. ISO 8601 時間點格式是一個好的解決方法(yyyy-MM-dd’T’HH:mm:ss.SSS’Z’). 推薦所有的 request &amp; response 以及 body content 都使用此標準</p><p>如果你剛好在開發 Java 相關的系統, <code>DateAdapterJ</code> 函式庫可以幫助你輕鬆解析和創建 ISO 8601 規格的日期和時間系統和 HTTP 1.1 (RFC 1123)格式的 header</p><p>至於用於基於瀏覽器的 UI, ECMAScript 5 規格包含如何用 JavaScript 解析和創建 ISO 8601 格式的日期. 這個規格是可以符合大多主流瀏覽器的. </p><h3 id="在-Headers-的時間序列"><a href="#在-Headers-的時間序列" class="headerlink" title="在 Headers 的時間序列"></a>在 Headers 的時間序列</h3><h2 id="安全類服務"><a href="#安全類服務" class="headerlink" title="安全類服務"></a>安全類服務</h2><p>所有驗證類服務皆需要透過 SSL 傳輸, 包含 JWT, Basic auth, OAuth2 等<br>:::info<br>註: 安全類的內容有點過期, 如果要最新的驗證/授權機制請至 <a href="https://oauth.net/2/" target="_blank" rel="noopener">OAuth2</a><br>:::</p><h3 id="Authentication-驗證"><a href="#Authentication-驗證" class="headerlink" title="Authentication(驗證)"></a>Authentication(驗證)</h3><p>當下最好的作法是透過 OAuth 作為驗證機制</p><h3 id="Authorization-授權"><a href="#Authorization-授權" class="headerlink" title="Authorization(授權)"></a>Authorization(授權)</h3><p>服務的授權並沒有與驗證有很大的差別, 他的問題是基於: “這個規範有權限取得這個資源嗎?” 基於規格, 資源 和權限的三重奏, 我們是能夠有一個授權服務來符合這個概念. 我們可以透過這些抽象化<br>的概念來為每個授權規範建構一個可以快取的通行控制清單(ACL)</p><h3 id="Application-Secutity"><a href="#Application-Secutity" class="headerlink" title="Application Secutity"></a>Application Secutity</h3><p>開發一個安全的網頁應用同樣適用於 RESTful 服務</p><ul><li>在伺服器端驗證所有使用者輸入. 接受 “已知的” 好輸入, 拒絕壞輸入</li><li>能防止 SQL 和 NoSQL 注入攻擊</li><li>用已知的第三方函式庫來編解碼資料, 例如微軟的 Anti-XSS 或是 OWASP 的 AntiSammy</li><li>限制請求/回覆區域的訊息大小</li><li>服務應該要只顯示泛化的錯誤訊息(不要回傳詳細的程式錯誤訊息)</li><li>考慮商業邏輯攻擊法, 例如攻擊者可以跳過多重驗證的過程並不需要輸入信用卡資訊來送出購買請求嗎？</li><li>紀錄可疑的動作</li></ul><p>RESTful 額外的安全考量:</p><ul><li>驗證畸形的 JSON 資料</li><li>動詞應該要只能夠被使用在允許的 http method, 例如:<ul><li>GET request 不能刪除任何實體. DELETE 才能</li><li>要注意 race conditions</li></ul></li></ul><p>API Gateways 可以用在 API 的監控, 節流, 和通行控制上. 以下功能可以透過 Gateway 或是 RESTful 服務實現</p><ul><li>監控 API 的使用量和檢查有沒有異常的流量</li><li>節流 API 用量來限制可疑的使用者透過 API 來進行 DDOS 和黑名單可疑 IP</li><li>儲存 API 金鑰在加密過的金鑰庫</li></ul><h2 id="快取和系統延展性"><a href="#快取和系統延展性" class="headerlink" title="快取和系統延展性"></a>快取和系統延展性</h2><p>快取透過在系統增加一層來消除遠端呼叫取得的資料來給予系統延展性. 服務透過設定 headers 來賦予 response 能夠快取的能力. 在 HTTP 1.0 與 HTTP 1.1 的快取 header 是不一樣的, 所以伺服器需要支援兩者. 以下表格是 GET request 能夠支援快取的最少 header, 以及一些解釋和合適的值</p><table><thead><tr><th>HTTP Header</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>Date</td><td>Date and time the response was returned (in RFC1123 format).</td><td>Date: Sun, 06 Nov 1994 08:49:37 GMT</td></tr><tr><td>Cache-Control</td><td>The maximum number of seconds (max age) a response can be cached. However, if caching is not supported for the response, then no-cache is the value.</td><td>Cache-Control: 360 Cache-Control: no-cache</td></tr><tr><td>Expires</td><td>If max age is given, contains the timestamp (in RFC1123 format) for when the response expires, which is the value of Date (e.g. now) plus max age. If caching is not supported for the response, this header is not present.</td><td>Expires: Sun, 06 Nov 1994 08:49:37 GMT</td></tr><tr><td>Pragma</td><td>When Cache-Control is ‘no-cache’ this header is also set to ‘no-cache’. Otherwise, it is not present.</td><td>Pragma: no-cache</td></tr><tr><td>Last-Modified</td><td>The timestamp that the resource itself was modified last (in RFC1123 format).</td><td>Last-Modified: Sun, 06 Nov 1994 08:49:37 GMT</td></tr></tbody></table><p>一個簡化的版本是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: 86400</span><br><span class="line">Date: Wed, 29 Feb 2012 23:01:10 GMT</span><br><span class="line">Last-Modified: Mon, 28 Feb 2011 13:10:14 GMT</span><br><span class="line">Expires: Thu, 01 Mar 2012 23:01:10 GMT</span><br></pre></td></tr></table></figure><p>以下是如果快取被關閉的情況下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure><h3 id="Etag-Header"><a href="#Etag-Header" class="headerlink" title="Etag Header"></a>Etag Header</h3><p><a href="https://zh.wikipedia.org/zh-tw/HTTP_ETag" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-tw/HTTP_ETag</a><br>由於使用 Etag 可能會觸法, 我就沒有翻譯了, 取自維基百科:</p><blockquote><p>由於HTTP cookie被越來越多的注重隱私保護的用戶刪除，可以將ETag用來追蹤唯一用戶。2011年7月，Ashkan Soltani和加州大學伯克利分校的一組研究者，包括Hulu.com將ETag用於追蹤用途。Hulu和KISSmetrics在2011年7月29日停止了這樣的追蹤，而KISSmetrics和超過20位其用戶面臨關於「無法刪除」的cookie的集體訴訟，其中包括了ETag的使用。 因為ETag由瀏覽器保存，並且在訪問統一資源時隨之後請求返回，一個追蹤伺服器可以輕鬆地重複設定任何從瀏覽器收到的ETag，以保持ETag不變，類似於持久cookie。額外的緩存頭部也能增強ETag的持久性。根據實現，ETag可以通過清除瀏覽器緩存清除。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RESTful-Service-Best-Practices-2013&quot;&gt;&lt;a href=&quot;#RESTful-Service-Best-Practices-2013&quot; class=&quot;headerlink&quot; title=&quot;RESTful Service Best P
      
    
    </summary>
    
    
      <category term="RESTful" scheme="https://robinsonweng.github.io/categories/RESTful/"/>
    
    
      <category term="RESTful" scheme="https://robinsonweng.github.io/tags/RESTful/"/>
    
  </entry>
  
  <entry>
    <title>評論以前的文章</title>
    <link href="https://robinsonweng.github.io/2022/01/08/comment-myself/"/>
    <id>https://robinsonweng.github.io/2022/01/08/comment-myself/</id>
    <published>2022-01-08T04:08:47.000Z</published>
    <updated>2023-06-15T09:05:13.545Z</updated>
    
    <content type="html"><![CDATA[<p>很久沒有更新文章了，說要馬上更新技術文章可能不太行，所以想說先來評論/吐槽自己以前寫的文章…尷尬癌警報。當然，這也可以作為一個里程碑，跟自己證明哪部分變強了，哪部分還需要自己加強</p><p>先從這篇談起吧</p><h2 id="學程式要幹嘛"><a href="#學程式要幹嘛" class="headerlink" title="學程式要幹嘛"></a>學程式要幹嘛</h2><p>首先，標題的前提就有問題了</p><blockquote class="colorquote info"><p>請以解決問題為目的學程式語言</p></blockquote><p>程式語言並不是解決問題的”工具”，試想你今天是木工，家裡椅子不夠了，你想多造幾個椅子。請問: 解決問題的是鋸子、榔頭，還是最終成品椅子? 答案是椅子。程式語言在一個專題裡扮演的腳色是構築一個解決問題的模組、工具，而不是模組本身。不是釘子和榔頭解決了沒椅子的窘境，而是椅子本身解決了問題</p><blockquote class="colorquote info"><p>我某語言學到OO(物件導向)，請問我可以拿來幹嘛」</p></blockquote><p>學理論、基礎常常會有這種困惑是很正常的，畢竟理論沒用，只有用到的時候才有用，但那時學已經來不及了。</p><blockquote class="colorquote info"><p>不然你很容易在名為程式的知識大海當中迷茫</p></blockquote><p>會有這種問題，代表你並沒有接觸到資工當中不會動的部分，也就是基礎。懂linux，docker 和 container 本身就是特化版的linux，要上手並不難。懂http, TCP/IP，換網頁框架就跟換一種茶葉喝茶一樣，只是習慣的問題。</p><blockquote class="colorquote info"><p>如果沒有熱忱與堅持，學程式語言會死得很難看</p></blockquote><p>很多人喜歡把成功與努力掛在嘴邊，但實際上真正讓人生更充實、更多生產力的唯一法則只有培養習慣，情感這種東西就跟火一樣，燒起來快，滅掉也快，這也是為甚麼越王勾踐要臥薪嘗膽。這麼不穩定的東西你怎麼會期待他能夠引導你幾年的時間?<br>培養興趣有兩種，先天與後天，先天基本上是與生俱來，或是周遭環境不小心打開到你的開關。後天培養則是持續做一件事情，當你越做越熟練，越上手，自然就會漸漸喜歡上了</p><h2 id="新米工程師要怎麼點技能樹"><a href="#新米工程師要怎麼點技能樹" class="headerlink" title="新米工程師要怎麼點技能樹?"></a>新米工程師要怎麼點技能樹?</h2><blockquote class="colorquote info"><p>在人人皆可google的今天，會正拳早就不是什麼稀罕的事情了</p></blockquote><p>“會Google”這件事情只有剛用google，被大量訊息淹沒的人才會說嘴，在現在這個「做甚麼、在甚麼時候做、跟誰做」比努力還要重要的時代，會查詢資料真的沒什麼大不了的，重點是在篩選，而不是在做本身。我大可google stackoverflow 一堆垃圾code複製貼上然後說我會google。不懂篩選資料的結果就是寫演算法碰到一千個資料集就不會動了，浪費了一堆時間看沒有文檔備註的教學文結果發現整篇全錯 ect. 況且，用英文關鍵字與用中文關鍵字的搜尋結果可說是天差地別。</p><p>把基礎，英文學好，投入大量時間練習，遠比學一些花裡狐俏的實際多了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很久沒有更新文章了，說要馬上更新技術文章可能不太行，所以想說先來評論/吐槽自己以前寫的文章…尷尬癌警報。當然，這也可以作為一個里程碑，跟自己證明哪部分變強了，哪部分還需要自己加強&lt;/p&gt;
&lt;p&gt;先從這篇談起吧&lt;/p&gt;
&lt;h2 id=&quot;學程式要幹嘛&quot;&gt;&lt;a href=&quot;#學程
      
    
    </summary>
    
    
      <category term="碎碎念" scheme="https://robinsonweng.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="思想" scheme="https://robinsonweng.github.io/tags/%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Git experience with gitk</title>
    <link href="https://robinsonweng.github.io/2019/10/25/gitkexperience/"/>
    <id>https://robinsonweng.github.io/2019/10/25/gitkexperience/</id>
    <published>2019-10-25T15:08:47.000Z</published>
    <updated>2023-06-15T09:05:18.293Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/nl83IML.png" alt=""></p><p>前幾天把跟網友一起寫的專案用git上傳上去，礙於我不是很熟練指令，就跟照著網路上的教學把指令照打了進去，結果不小心pull到，我打的程式就被覆蓋過去了</p><p>後來基於朋友的幫助下又再次恢復了先前的branch，順便認知到git的重要性以及git指令的熟練度</p><p>而恢復原本的branch的方法則是用gitk這個工具來把git branch GUI化，一看就懂，非常方便!</p><p><img src="https://i.imgur.com/9Ll3S88.png" alt=""></p><h2 id="10-27更新"><a href="#10-27更新" class="headerlink" title="10/27更新:"></a>10/27更新:</h2><p>附上錯誤的指令、倒退至原本branch的神奇方法、被GUI化的branches以及起承轉合</p><p>我從github上面pull了一個專案下來，但是寫好以後想要push到我的github的fork，在指令不熟的狀況下意外地把專案又pull下來一次，導致origin master覆蓋local branch(SS)</p><p><code>出事後的branch們</code></p><p><img src="https://i.imgur.com/e4w3MDK.png" alt=""></p><p><code>不應該用pull，會導致覆蓋local branch</code></p><p><img src="https://i.imgur.com/JL7lux4.png" alt=""></p><p><code>倒退回brach的方法</code></p><ul><li>選定(checkout)想要被回朔的branch</li><li>複製想要回朔branch的sha1碼前幾位(4~7)</li><li>git reset –soft [commit hash]</li></ul><p>這樣就完成了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/nl83IML.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;前幾天把跟網友一起寫的專案用git上傳上去，礙於我不是很熟練指令，就跟照著網路上的教學把指令照打了進去，結果不小心pull到，我打的程式就被覆蓋過去了&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Git" scheme="https://robinsonweng.github.io/categories/Git/"/>
    
    
      <category term="git" scheme="https://robinsonweng.github.io/tags/git/"/>
    
      <category term="gitk" scheme="https://robinsonweng.github.io/tags/gitk/"/>
    
  </entry>
  
  <entry>
    <title>Python&#39;s Class Development Toolkit</title>
    <link href="https://robinsonweng.github.io/2019/10/06/python&#39;s-Class-Development-Toolkit/"/>
    <id>https://robinsonweng.github.io/2019/10/06/python&#39;s-Class-Development-Toolkit/</id>
    <published>2019-10-06T06:47:33.000Z</published>
    <updated>2023-06-15T09:04:50.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python’s-Class-Development-Toolkit-的重點整理"><a href="#Python’s-Class-Development-Toolkit-的重點整理" class="headerlink" title="Python’s Class Development Toolkit 的重點整理"></a>Python’s Class Development Toolkit 的重點整理</h2><blockquote class="colorquote info"><p><code>Raymond Hettinger</code> 一位常常出現在Python程式語言演講的大佬，曾經聽過他的<code>Transforming Code into Beautiful, Idiomatic Python</code> 聽過一次就愛上了他的演講風格，乾淨、簡潔、速度適中且幽默十足</p></blockquote><ol><li><p><code>__init__</code> is not a constructor:</p><ul><li>我曾經在寫Python也有這個疑問，為甚麼Python的建構子是叫做<code>__init__</code>而不是<code>__constructor__</code>?而實際上確實不是，self是本身class的實作，也就是說在<code>__init__</code>宣告以前，class已經建構好了，他是一個<code>initializer</code>，任務是將影片中的Radius存入字典當中。<br>2022-1-9 update:<br>如果真的要說python的建構子，那可能是 <strong>new</strong>，他是真的在class建構以前就開始運行了，所以如果有段程式碼想要在 <strong>init</strong> 以前運行，可以選擇 <strong>new</strong></li></ul></li><li><p><code>@classmethod</code>:</p><ul><li>如果我想要只呼叫一個method就可以達成:計算新的Radius同時更新到Class裡面，你可以在method中直接呼叫Class本身，但是這個舉動會導致繼承以後的method被影響，所以為了呼叫原class更新參數的當下又不會影響到繼承後的class，就是該使用 <code>@classmethod</code>中的cls參數來呼叫class的場合</li></ul></li><li><p><code>@staticmethod</code>:</p><ul><li><p>我想要寫一個function在class裡面，但是這個function的功能與class無關，所以你會陷入一種</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 寫進class裡面，但是用這個與class無關的function還是要實作一次物件</span><br><span class="line">2. 寫在class外面，但是這樣使用這個class的人就會找不到這個function</span><br></pre></td></tr></table></figure></li><li><p>這時候就是<code>@staticmethod</code>的出場時刻了，不需要實作但是仍然放在class裡面的method</p></li></ul></li><li><p><code>__method</code>:</p><ul><li><p>當我們在一個class當中要從一個method呼叫另外一個method我們會用<code>self.method()</code>但是self其實是指實作後的自己，也就是說self不只是class他自己，也包括被繼承的那些class，當繼承父class的子class也使用了相同名稱的method，原本的父class method就會被覆蓋。那麼要怎麼解決這個方法呢? 講者這邊提出個兩種方法，第一種方法就是在method被呼叫以前先複製一份，這樣一來，父class有自己的一份，繼承的子class也不會蓋過去原class的method，皆大歡喜(? 但是這對你來說是好方法，對其他人來說也是好方法，如果子class也照做一次，這段程式碼又會失效了XD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def method(self):</span><br><span class="line">    ...something</span><br><span class="line"></span><br><span class="line">_method &#x3D; method</span><br></pre></td></tr></table></figure><p>「所以為了贏得這個小學一年級的學你戰爭，我們需要在複製以前加上名字，這樣他只要複製到你很醜，他看到的就是某某很醜」，也就是在method前面加上class的名稱避免誤用，而這套流程因為太實用了，所以Python把它加了進去，也就是所謂的<code>__method</code></p><blockquote class="colorquote info"><p>所以其實<code>__method</code>跟privacy一點關係都沒有，反而是他的相反，它可以讓你的子class能夠更自由的去繼承、覆寫</p></blockquote></li></ul></li><li><p><code>@property</code>:<br> 有兩個用途</p><pre><code>1. 是在取得`.屬性`的時候，可以神奇的執行一件事情並取得這個值2. 當為了執行效率使用`__slots__`時，他會破壞原本取得變數的字典，而`@property`正是他的補救方案</code></pre></li></ol><p>結語:<br>    這篇演講真的是非常非常的紮實，學到很多東西以及觀念補正，推薦正在看class的朋友們!</p><p>有沒有曾經看過<code>@classmethod</code>或是<code>@staticmethod</code>的語法但還是搞不清楚應該用在甚麼情境的? 那你應該也來聽聽看<a href="https://www.youtube.com/watch?v=HTLu2DFOdTg&feature=youtu.be" target="_blank" rel="noopener">這個演講</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python’s-Class-Development-Toolkit-的重點整理&quot;&gt;&lt;a href=&quot;#Python’s-Class-Development-Toolkit-的重點整理&quot; class=&quot;headerlink&quot; title=&quot;Python’s Cla
      
    
    </summary>
    
    
      <category term="Python" scheme="https://robinsonweng.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://robinsonweng.github.io/tags/Python/"/>
    
      <category term="classtoolkit" scheme="https://robinsonweng.github.io/tags/classtoolkit/"/>
    
  </entry>
  
  <entry>
    <title>新米工程師要怎麼點技能樹?</title>
    <link href="https://robinsonweng.github.io/2019/09/26/skill-tree/"/>
    <id>https://robinsonweng.github.io/2019/09/26/skill-tree/</id>
    <published>2019-09-26T12:32:08.000Z</published>
    <updated>2023-06-15T09:05:43.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="習慣翻徵才啟事的我某一天發現一個很有趣的言論，他說"><a href="#習慣翻徵才啟事的我某一天發現一個很有趣的言論，他說" class="headerlink" title="習慣翻徵才啟事的我某一天發現一個很有趣的言論，他說:"></a>習慣翻徵才啟事的我某一天發現一個很有趣的言論，他說:</h2><blockquote class="colorquote warning"><p>技能點要多一點一些，不要侷限於一種語言或是技能</p></blockquote><p>但是這難道意味著我要從Python的爬蟲直接跳到寫網頁嗎?<br>當然不是，他們的意思是會一套能接技的技能<br>講白了是希望你有一套拳法，而不是只會正拳<br>在人人皆可google的今天，會正拳早就不是什麼稀罕的事情了<br>舉個例子，你能不能夠構築一個數據分析系統<br>爬蟲 –&gt; 數據清洗 –&gt; 資料倉庫 –&gt; 資料視覺化 –&gt; 機器學習<br>靠己力跑完這個流程並熟練他?</p><p><a href="http://www.finereport.com/tw/data-analysis/rumen-dao-jinjie.html?fbclid=IwAR2Od9WWuIcxAXdi07EvlO0CVKbY2TmcP74icQIwbllihMUnw0OxGFnneco" target="_blank" rel="noopener">ref</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;習慣翻徵才啟事的我某一天發現一個很有趣的言論，他說&quot;&gt;&lt;a href=&quot;#習慣翻徵才啟事的我某一天發現一個很有趣的言論，他說&quot; class=&quot;headerlink&quot; title=&quot;習慣翻徵才啟事的我某一天發現一個很有趣的言論，他說:&quot;&gt;&lt;/a&gt;習慣翻徵才啟事的我某
      
    
    </summary>
    
    
      <category term="碎碎念" scheme="https://robinsonweng.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="思想" scheme="https://robinsonweng.github.io/tags/%E6%80%9D%E6%83%B3/"/>
    
      <category term="程式" scheme="https://robinsonweng.github.io/tags/%E7%A8%8B%E5%BC%8F/"/>
    
      <category term="數據分析" scheme="https://robinsonweng.github.io/tags/%E6%95%B8%E6%93%9A%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>學程式要幹嘛?</title>
    <link href="https://robinsonweng.github.io/2019/09/23/howtoprogram/"/>
    <id>https://robinsonweng.github.io/2019/09/23/howtoprogram/</id>
    <published>2019-09-23T11:31:49.000Z</published>
    <updated>2023-06-15T09:05:28.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="請以解決問題為目的學程式語言"><a href="#請以解決問題為目的學程式語言" class="headerlink" title="請以解決問題為目的學程式語言"></a>請以解決問題為目的學程式語言</h1><p>網路上時常就會看到:</p><blockquote class="colorquote warning"><p>「我某語言學到OO(物件導向)，請問我可以拿來幹嘛」</p></blockquote><p>這是一種學語言的壞習慣，為了學而學，除非你有著考大學大考的毅力，以及制訂一份到退休的人生規劃，不然你很容易在名為程式的知識大海當中迷茫</p><p>在軟工發達的現今社會，光是熱門的程式語言就有數十種，連站穩腳跟都辦不到的人就別做夢了</p><p>如果僅僅是要拓展自己的科技樹，可以從這個語言的特色學起，例如Python的應用範圍如下:</p><ol><li>Web程式(Django, Flask, Pyramid)</li><li>作業系統(Anaconda)</li><li>GUI開發(TKinter, PyQt)</li><li>遊戲(pygame)</li><li>數據處理(numpy, scipy, matplotlib)</li><li>機器學習/深度學習(Tensorflow2.0, Pytorch)</li><li>爬蟲(Scrapy, BeautifulSoup)</li></ol><p>如果沒有熱忱與堅持，學程式語言會死得很難看，不過聽說畢業的大學生也不一定會寫程式，會程式語言不知道要朝哪個方向好像也是合情合理(?</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;請以解決問題為目的學程式語言&quot;&gt;&lt;a href=&quot;#請以解決問題為目的學程式語言&quot; class=&quot;headerlink&quot; title=&quot;請以解決問題為目的學程式語言&quot;&gt;&lt;/a&gt;請以解決問題為目的學程式語言&lt;/h1&gt;&lt;p&gt;網路上時常就會看到:&lt;/p&gt;
&lt;blockq
      
    
    </summary>
    
    
      <category term="碎碎念" scheme="https://robinsonweng.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="思想" scheme="https://robinsonweng.github.io/tags/%E6%80%9D%E6%83%B3/"/>
    
      <category term="學習" scheme="https://robinsonweng.github.io/tags/%E5%AD%B8%E7%BF%92/"/>
    
  </entry>
  
</feed>
